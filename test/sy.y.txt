%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int nb_ligne=1;
int col=1;
char* tp;
char* tp2;
char sf[500];                       
int i;
char txt[500];
char savety [10][50];
int tsavet=0;
char op2;
float t1[2];
int k=0;
char t[10];
char* sgf;
char* cmp;
int tsf=0;
float val;
char tempo[10];
char bou[10];
char tipe[10];
int yylex();
char sauvType[20];

int DoubleDeclaration();
void insererTYPE();
void insererVAL();
char* return_TYPE();
float return_VAL();
int yyerror ();

%}
%union {
char* string;
char chr;
int entier;
float reel;
}
%right sep_not
%left  op_div op_mult op_add op_sub
%left sep_or sep_and 
%left sep_lesser sep_greater sep_GreaterEqua sep_LesserEqual sep_equal sep_diff
%token mc_stp mc_prgId mc_Datadiv mc_ProcDiv mc_idDiv mc_workinSS
%token <string>t_int <string>t_float <string>t_char <string>t_string
%token line size mc_cst sep_and sep_or sep_not sep_greater sep_lesser sep_GreaterEqua sep_LesserEqual sep_equal sep_diff
mc_accept mc_display mc_adr
%token sf_float sf_char sf_string sf_entier dpt affect ou ver pt op_add op_sub op_mult op_div
%token mc_if  mc_else end move to <string>idf
%token <chr>cst_char <string>cst_string <reel>cst_float <entier>cst_int  op cp gil
%start S

%%
S: mc_idDiv mc_prgId idf mc_Datadiv mc_workinSS Declarations_Var mc_ProcDiv Instructions mc_stp
{ printf("syntaxe correcte\n");
 YYACCEPT;
 }
 ;
 Declarations_Var:  Varsimple Declarations_Var 
            | Tableau Declarations_Var 
            | Cons Declarations_Var 
            |
 ;
 Varsimple: List_names 
 ;
 List_names:idf Type pt{if(DoubleDeclaration($1)==0) {insererTYPE($1,sauvType);}
 else 
 {printf("erreur semantique: double Declaration de %s a la ligne %d collone %d \n",$1,nb_ligne,col);YYERROR;}}
 |idf ou List_names {if(DoubleDeclaration($1)==0) insererTYPE($1,sauvType);
 else 
 {printf("erreur semantique: double Declaration de %s a la ligne %d collone %d \n",$1,nb_ligne,col); YYERROR;}}
 ;
 Type: t_int {strcpy(sauvType,"entier");}
 | t_float   {strcpy(sauvType,"real");}
 | t_char    {strcpy(sauvType,"char");}
 |t_string      {strcpy(sauvType,"chaine");}
 ;
 Tableau:idf line cst_int ver size cst_int Type pt {if(DoubleDeclaration($1)==0) 
                                                  {insererTYPE($1,sauvType);
												  if($3>=$6) {printf("erreur semantique:parcours du tableau errone a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}}
                                                else 
                                                {printf("erreur semantique: double Declaration de %s a la ligne %d collone %d \n",$1,nb_ligne,col);YYERROR;} }
 ;
 Cons: mc_cst idf affect Valeur pt {if(DoubleDeclaration($2)==0) insererTYPE($2,sauvType);
 else 
 {printf("erreur semantique: double Declaration de %s a la ligne %d collone %d \n",$2,nb_ligne,col);YYERROR;} }
 | mc_cst idf Type pt{if(DoubleDeclaration($2)==0) insererTYPE($2,sauvType);
 else 
 {printf("erreur semantique: double Declaration de %s a la ligne %d collone %d \n",$2,nb_ligne,col); YYERROR;}}
 ;
 Valeur: cst_char 
 |cst_float 
 |cst_int 
 |cst_string
 ;
 Instructions: Inst Instructions 
           |
 ;
 Inst: Affectation 
        |Accept 
        |Display 
        |Condition 
        |Boucle
 ;
 
Affectation: idf affect cst_int pt {if(DoubleDeclaration($1)==0) 
                                     {printf("erreur semantique: non Declaration de %s a la ligne %d collone %d \n",$1,nb_ligne,col);YYERROR;}
			                       else{char tp[20];
								        strcpy(tp,return_TYPE($1));
			                            
						                if(strcmp(tp,"entier")!=0)
										{printf("erreur semantique alo alo : %s a la ligne %d collone %d \n",$1,nb_ligne,col);YYERROR;}
										else{float v=$3;insererVAL($1,&v);}
						
			         
						
						
						}	}

			 |idf affect cst_float pt {if(DoubleDeclaration($1)==0) 
                                     {printf("erreur semantique: non Declaration de %s a la ligne %d collone %d \n",$1,nb_ligne,col);YYERROR;}
			                       else{char tp[20];
								        strcpy(tp,(char*)return_TYPE($1));
			                            printf("%s\n",tp);
						                if(strcmp(tp,"real")!=0)
										{printf("erreur semantique alo alo : %s a la ligne %d collone %d \n",$1,nb_ligne,col);YYERROR;}
										else{float v=$3;printf("%f\n",v);insererVAL($1,&v);}
						
			         
						
		
						}	}
             |idf affect cst_char pt {if(DoubleDeclaration($1)==0) 
                                     {printf("erreur semantique: non Declaration de %s a la ligne %d collone %d \n",$1,nb_ligne,col);YYERROR;}

                                       else {if(strcmp(return_TYPE($1),"char")!=0)		
                                       {printf("erreur semantique: %s a la ligne %d collone %d \n",$1,nb_ligne,col);YYERROR;}}}
             |idf affect cst_string pt{if(DoubleDeclaration($1)==0) 
                                     {printf("erreur semantique: non Declaration de %s a la ligne %d collone %d \n",$1,nb_ligne,col);YYERROR;} 
									 else{if(strcmp(return_TYPE($1),"chaine")!=0)		
                                       {printf("erreur semantique: %s a la ligne %d collone %d \n",$1,nb_ligne,col);YYERROR;}									   
									   
									   }}
             |idf affect idf pt       {if(DoubleDeclaration($1)==0) 
                                     {printf("erreur semantique: non Declaration de %s a la ligne %d collone %d \n",$1,nb_ligne,col);YYERROR;} 
									 else{if(strcmp(return_TYPE($1),return_TYPE($3))!=0){	
                                       printf("erreur semantique: %s a la ligne %d collone %d \n",$1,nb_ligne,col);
									   YYERROR;}
									   }}
			|idf affect Expression pt 	{
									if(strcmp(tempo,return_TYPE($1))==0){
									insererVAL($1,&val);
									
									}else{if(strcmp(return_TYPE($1),"real")==0 && strcmp(tempo,"entier")==0){
									insererVAL($1,&val);
									}else{
									
									
									printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
									
                                    }
									}
									strcpy(tempo,"");
									val=0;
									}
 ;
Expression:  Consv operateur Expression  
			|Consv operateur Consv {
									if(op2=='+'){
									val=t1[0]+t1[1];
									}else{
									if(op2=='-'){
									val=t1[0]-t1[1];
									}else{
									if(op2=='*'){
									val=t1[0]*t1[1];
									}else{
									if(op2=='/'){
									if(t1[1]==0){ printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
									}else{
									val=t1[0]/t1[1];
									}
									}
									}
									}
									}
									k=0;
									
			
			}
            |Consv operateur Expression_p
 
;
Expression_p: op Expression cp 
              |op Expression_p cp
              |op Expression_p cp operateur Expression_p
              |op Expression_p cp operateur Expression
              |op Expression_p cp operateur Consv
              |op Expression cp operateur Consv
              |op Expression cp operateur Expression
;			  
Consv:cst_float {
				if(strcmp(tempo,"")==0){
				strcpy(tempo,"real");
				t1[k]=$1;
				k++;
				}else{
				if(strcmp(tempo,"real")==0 || strcmp(tempo,"entier")==0){
				strcpy(tempo,"real");
				t1[k]=$1;
				k++;
				}else{
				printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
				
				}
				}
				
				
				
				}
     |cst_int {
				if(strcmp(tempo,"")==0){
				strcpy(tempo,"entier");
				t1[k]=$1;
				k++;
				}else{
				if(strcmp(tempo,"real")==0 || strcmp(tempo,"entier")==0){
				t1[k]=$1;
				k++;
				}else{
				printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
				
				}
				
				}}
     |idf {if(DoubleDeclaration($1)==0) 
             {printf("erreur semantique: non Declaration de %s a la ligne %d collone %d \n",$1,nb_ligne,col);YYERROR;}			 
			 else{
			 
			 if(return_VAL($1)>32767){
			 printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
			 }
			 else{
			 
			 if(strcmp(tempo,"")==0){
				strcpy(tempo,return_TYPE($1));
				t1[k]=return_VAL($1);
				k++;
				}else{
				if(strcmp(tempo,return_TYPE($1))==0){
				t1[k]=return_VAL($1);
				k++;
				}else{
				printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
				
				}
				
				}}}}
; 
operateur: op_add {op2='+';}
          |op_sub {op2='-';}
          |op_mult {op2='*';}
		  |op_div {op2='/';}
;
Accept: mc_accept op cst_string dpt mc_adr idf cp pt{if(DoubleDeclaration($6)==0) 
                                     {printf("erreur semantique: non Declaration de %s a la ligne %d collone %d \n",$6,nb_ligne,col);YYERROR;}
									 else {char* ss; 
									 strcpy(ss,$3);
									 if(strcmp((char*)return_TYPE($6),"entier")==0 ){
									 if(return_VAL($6)>32767){
									 printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}
									 if(ss[1]!='$')
									 {printf("erreur semantique type different a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}}
									  else{if(strcmp((char*)return_TYPE($6),"real")==0 ){
									  if(return_VAL($6)>32767){
									 printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}
									 if(ss[1]!='%')
									 {printf("erreur semantique type different a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}}
									  else{if(strcmp((char*)return_TYPE($6),"char")==0 ){
									 if(ss[1]!='&')
									 {printf("erreur semantique type different a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}}
									  else{if(strcmp((char*)return_TYPE($6),"chaine")==0 ){
									 if(ss[1]!='#')
									 {printf("erreur semantique type different a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}}
									 }}}}}
;
Display: mc_display op cst_string dpt Choi cp pt{
					
					strcpy(txt,(char*)$3);
					for(i=0;i<strlen(txt);i++)
					{if(txt[i]=='#' || txt[i]=='%' || txt[i]=='$' || txt[i]=='&' ){
					
					sf[tsf]=txt[i];
					tsf++;
					}}
					if(tsf!=tsavet)
					{printf("erreur semantique nombre de signe de formatage incorect a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}
					else
					{for(i=0;i<tsavet;i++){
					if(strcmp(savety[i],"real")==0){
					if(sf[i]!='%')
					{printf("erreur semantique : signe de formatage montre un type different a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}
					}else{
					if(strcmp(savety[i],"entier")==0){
					if(sf[i]!='$')
					{printf("erreur semantique : signe de formatage montre un type different a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}
					}else{
					if(strcmp(savety[i],"char")==0){
					if(sf[i]!='&')
					{printf("erreur semantique : signe de formatage montre un type different a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}
					}else{
					if(strcmp(savety[i],"chaine")==0){
					if(sf[i]!='#')
					{printf("erreur semantique : signe de formatage montre un type different a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}
					}
					}
					}}}}
					
					tsf=0;
					tsavet=0;
					}
					
												
;
Choi:idf ver Listidf {if(DoubleDeclaration($1)==0) 
                {printf("erreur semantique: non Declaration de %s a la ligne %d collone %d \n",$1,nb_ligne,col);YYERROR;}
				else{if(strcmp(return_TYPE($1),"entier")==0 || strcmp(return_TYPE($1),"entier")==0){
				if(return_VAL($1)>32767){printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}
				else{strcpy(savety[tsavet],return_TYPE($1));tsavet++;}
				
				
				}else{strcpy(savety[tsavet],return_TYPE($1));tsavet++;}
				
				
				}}
     |idf    {if(DoubleDeclaration($1)==0) 
                {printf("erreur semantique: non Declaration de %s a la ligne %d collone %d \n",$1,nb_ligne,col);YYERROR;}
				else{if(strcmp(return_TYPE($1),"entier")==0 || strcmp(return_TYPE($1),"entier")==0){
				if(return_VAL($1)>32767){printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}
				else{strcpy(savety[tsavet],return_TYPE($1));tsavet++;}
				
				
				}else{strcpy(savety[tsavet],return_TYPE($1));tsavet++;}
				
				
				}}
     |
;
Listidf:idf {if(DoubleDeclaration($1)==0) 
                {printf("erreur semantique: non Declaration de %s a la ligne %d collone %d \n",$1,nb_ligne,col);YYERROR;}
				else{if(strcmp(return_TYPE($1),"entier")==0 || strcmp(return_TYPE($1),"entier")==0){
				if(return_VAL($1)>32767){printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}
				else{strcpy(savety[tsavet],return_TYPE($1));tsavet++;}
				
				
				}else{strcpy(savety[tsavet],return_TYPE($1));tsavet++;}
				
				
				}}
             |idf ver Listidf {if(DoubleDeclaration($1)==0) 
                {printf("erreur semantique: non Declaration de %s a la ligne %d collone %d \n",$1,nb_ligne,col);YYERROR;}
				else{if(strcmp(return_TYPE($1),"entier")==0 || strcmp(return_TYPE($1),"entier")==0){
				if(return_VAL($1)>32767){printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}
				else{strcpy(savety[tsavet],return_TYPE($1));tsavet++;}
				
				
				}else{strcpy(savety[tsavet],return_TYPE($1));tsavet++;}
				
				
				}}
;
Condition:mc_if  op Somthing cp dpt Instructions end
|mc_if op Somthing cp dpt Instructions mc_else dpt Instructions end
;
Somthing:Condi 
|sep_not Condi
|Condi sep_or Somthing 
|Condi sep_and Somthing
|sep_not Condi sep_or Somthing 
|sep_not Condi sep_and Somthing
;
Condi: Expression operation Expression {strcpy(tempo,"");}
|idf operation idf {if(DoubleDeclaration($1)==0) 
                    {printf("Erreur semantique: %s variable non declaree a la ligne %d\n",$1,nb_ligne);YYERROR;}
					else{
				   if(strcmp(return_TYPE($1),return_TYPE($3))!=0){
				   printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
				   }else{if(strcmp(return_TYPE($3),"entier")==0 || strcmp(return_TYPE($3),"real")==0){
				    if(return_VAL($1)>32767 || return_VAL($3)>32767){
					printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
					}
				   
				   
				   }
				   }}}
|idf sep_equal cst_char {if(DoubleDeclaration($1)==0) 
                   {printf("Erreur semantique: %s variable non declaree a la ligne %d\n",$1,nb_ligne);YYERROR;}else{
				   if(strcmp(return_TYPE($1),"char")!=0){
				   printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
				   }
				   
				   }}       
|idf sep_equal cst_string {if(DoubleDeclaration($1)==0) 
                     {printf("Erreur semantique: %s variable non declaree a la ligne %d\n",$1,nb_ligne);YYERROR;}
					 else{
				   if(strcmp(return_TYPE($1),"chaine")!=0){
				   printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
				   }}}
|cst_char sep_equal idf  {if(DoubleDeclaration($3)==0) 
                    {printf("Erreur semantique: %s variable non declaree a la ligne %d\n",$3,nb_ligne);YYERROR;}
					else{
				   if(strcmp(return_TYPE($3),"char")!=0){
				   printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
				   }}    }
|cst_string sep_equal idf {if(DoubleDeclaration($3)==0) 
                     {printf("Erreur semantique: %s variable non declaree a la ligne %d\n",$3,nb_ligne);YYERROR;}
					 else{
				   if(strcmp(return_TYPE($3),"chaine")!=0){
				   printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
				   }}  }
|idf operation cst_int {if(DoubleDeclaration($1)==0) 
                   {printf("Erreur semantique: %s variable non declaree a la ligne %d\n",$1,nb_ligne);YYERROR;}else{
				   if(strcmp(return_TYPE($1),"entier")!=0){
				   printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
				   }else{
				   if(return_VAL($1)>32767){
					printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
					}
				   
				   }
				   
				   }}       
|cst_int operation idf {if(DoubleDeclaration($3)==0) 
                   {printf("Erreur semantique: %s variable non declaree a la ligne %d\n",$1,nb_ligne);YYERROR;}else{
				   if(strcmp(return_TYPE($3),"entier")!=0){
				   printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
				   }else{
				   if(return_VAL($3)>32767){
					printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
					}
				   
				   }
				   
				   }}     
|idf operation cst_float {if(DoubleDeclaration($1)==0) 
                   {printf("Erreur semantique: %s variable non declaree a la ligne %d\n",$1,nb_ligne);YYERROR;}else{
				   if(strcmp(return_TYPE($1),"real")!=0){
				   printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
				   }else{
				   if(return_VAL($1)>32767){
					printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
					}
				   
				   }
				   
				   }}     
|cst_float operation idf {if(DoubleDeclaration($3)==0) 
                   {printf("Erreur semantique: %s variable non declaree a la ligne %d\n",$1,nb_ligne);YYERROR;}else{
				   if(strcmp(return_TYPE($3),"real")!=0){
				   printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
				   }else{
				   if(return_VAL($3)>32767){
					printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;
					}
				   
				   }
				   
				   }}      
|cst_float operation cst_float
|cst_int operation cst_int
;
operation:sep_greater 
|sep_lesser 
|sep_GreaterEqua 
|sep_LesserEqual 
|sep_diff 
|sep_equal
;

Boucle: move Idcon to Idcon Instructions end {strcpy(bou,"")}
;
Idcon: idf {if(DoubleDeclaration($1)==0) 
              {printf("Erreur semantique: %s variable non declaree a la ligne %d\n",$1,nb_ligne);YYERROR;}
			  else{
			    if(strcmp(return_TYPE($1),"entier")==0){
				if(return_VAL($1)>32767){printf("erreur semantique:  a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}
				else{
				if(strcmp(bou,"")==0)
			  {strcpy(bou,return_TYPE($1));}
			  else{
			  if(strcmp(bou,return_TYPE($1))!=0)
			  {printf("erreur semantique: type different des variable a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}
			  }
				
				
				}}else{  
			  if(strcmp(bou,"")==0)
			  {strcpy(bou,return_TYPE($1));}
			  else{
			  if(strcmp(bou,return_TYPE($1))!=0)
			  {printf("erreur semantique: type different des variable a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}
			  }
			  }}}
|cst_int{
			 if(strcmp(bou,"")==0)
			 {strcpy(bou,"entier");}else{
			  if(strcmp(bou,"entier")!=0)
			  {printf("erreur semantique: type different des variable a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}
			  }
			  }
|cst_char{
			 if(strcmp(bou,"")==0)
			  {strcpy(bou,"char");}
			  else{
			  if(strcmp(bou,"char")!=0){
			  {printf("erreur semantique: type different des variable a la ligne %d collone %d \n",nb_ligne,col);YYERROR;}
			  }
			  }
			  }
;





%%
int yywrap()
{return 1;}
int yyerror (char* msg)
{printf("Erreur syntaxique , ligne %d , colonne %d :entite %s \n",nb_ligne,col,msg);
return 0;}